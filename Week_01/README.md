JVM核心技术--基础知识

1.第1课 JVM 核心技术--基础知识

1. 这个没啥好说的，自己看pdf
2. Java 是一种面向对象、静态类型、编译执行，
   有 VM/GC 和运行时、跨平台的高级语言。

2.第1课2. Java 字节码技术

1. 什么是字节码？
   1. Java bytecode 由单字节（byte）的指令组成，理论上最多支持 256 个操作码（opcode）。
      实际上 Java 只使用了200左右的操作码， 还有一些操作码则保留给调试操作。
      根据指令的性质，主要分为四个大类：
      1. 栈操作指令，包括与局部变量交互的指令
      2. 程序流程控制指令
      3. 对象操作指令，包括方法调用指令
      4. 算术运算以及类型转换指令
2. 查看字节码文件javap -c -verbose xxx.class
3. a开头的是引用类型,i是int,d是double,f是float,long是l,其他的一些基本类型都作为int参加运算
4. ifne是if,然后在for循环中,if_icmpge这里会进行判断(大于等于)
5. 具体的字节码可以自己上百度搜索

3.第1课3. JVM 类加载器

1. 类加载时机

   1.当虚拟机启动时，初始化用户指定的主类，就是启动执行的 main方法所在的
   类；
   2.当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类，就是
   new一个类的时候要初始化；
   3.当遇到调用静态方法的指令时，初始化该静态方法所在的类；
   4.当遇到访问静态字段的指令时，初始化该静态字段所在的类；
   5.子类的初始化会触发父类的初始化；
   6.如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初
   始化，会触发该接口的初始化；
   7.使用反射 API 对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射
   调用要么是已经有实例了，要么是静态方法，都需要初始化；
   8.当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的
   类。

2. 不会初始化（可能会加载）

   1.通过子类引用父类的静态字段，只会触发父类的初始化，而不会触发子类的初始化。

   2.定义对象数组，不会触发该类的初始化。

   3.常量在编译期间会存入调用类的常量池中，本质上并没有直接引用定义常量的类，不
   会触发定义常量所在的类。

   4.通过类名获取 Class 对象，不会触发类的初始化，Hello.class 不会让 Hello 类初始
   化。

   5.通过 Class.forName 加载指定类时，如果指定参数 initialize 为 false 时，也不会触
   发类初始化，其实这个参数是告诉虚拟机，是否要对类进行初始化。Class.forName
   （“jvm.Hello”）默认会加载 Hello 类。

   6.通过 ClassLoader 默认的 loadClass 方法，也不会触发初始化动作（加载了，但是
   不初始化）。

3. JDK9中怎么进行反射调用addUrl？

   1. Calss.forName("xxx",new UrlClassLoader("dddd"))

4.第1课4. JVM 内存模型

​	具体的看课件，好好看一下~

1. CPU乱序执行
2. volatile关键字
3. 原子性操作
4. 内存屏障

xmx 不要超过系统可用内存的60-80%

例如:4g 就配置 2.4g~3.2g