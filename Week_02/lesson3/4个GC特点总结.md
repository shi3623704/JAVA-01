1.Serial GC

特点：单线程，在进行垃圾收集时会暂停所有的用户线程，新生代采用复制算法，老年代采用标记整理算法。但是因为简单，所以在单线程的情况下，效率高，额外内存消耗少，对于客户端模式下的虚拟机来说还是不错的选择。

2.Parallel GC

特点：较高的吞吐量，吞吐量=运行用户代码的时间/(运行用户代码的时间+运行垃圾收集的时间)，使用标记整理算法，支持多线程并发收集，是一个并行的垃圾收集器。

3.CMS

使用的是ParNew和CMS的组合进行垃圾回收，ParNew就相当于是一个并行的Serial GC，就不过多介绍了。下面主要说一下CMS，CMS是一个并发的垃圾回收器，只要短暂的两次STW，其他时刻都可以和用户代码一起执行；

​	CMS的运作主要分成四部分：

​	1.初始标记(STW)：标记一下GC Roots 能直接关联到的对象，速度很快

​	2.并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程。

​	3.重新标记(STW)：修正并发时期，用户线程继续运作而导致标记产生变动的那一部分对象的标记记录

​	4.并发清除：清理删除掉标记阶段判定的已经死亡的对象。由于不需要移动对象，因此这部分也可以并发执行

缺点：

​	1. 对处理器的资源非常的敏感：在并发阶段，虽然不会导致用户线程停顿，但是因为占用了一部分处理器的计算能力，所以多少都会影响到应用程序变慢，降低总体的吞吐量。

​	2.无法处理浮动垃圾：有可能会出现“Concurrent Mode Failure”，进而导致一次完整的FullGC的出现。因为并发标记阶段和并发清理阶段，用户线程是还在运行的，所以程序自然而然的会产生新的垃圾不断产生，这部分的垃圾是在标记过程结束之后出现的，所以在本次的收集中，CMS无法回收它们。但是因为并发，所以还要预留足够的时间来给用户线程使用，如果在CMS运行时，预留的内存无法满足程序分配新对象的需要，就会出现并发失败，从而会产生一次完整的FullGC，同时STW，并且使用单线程的Serial Old来进行垃圾回收

​	3.会产生大量的空间碎片：标记清除算法会产生大量的空间碎片；空间碎片过多的时候，往往会出现空间还有很多，但是没有连续的空间来分配给大对象，从而会提前出发一次完整的Full GC；为了解决这个问题：CMS有一个参数可以设置：-XX:+UseCMSCompactAtFullCollection,来配置在进行FullGC的时候对空间碎片进行整理；还有一个配置就是：-XX:+CMSFullGCsBeforeCompaction,用来配置可以进行若干次不整理空间碎片的Full GC，再执行整理空间的Full GC，(默认是0，每次Full GC都会整理空间碎片)

4.G1

G1把堆内存分成了多个大小相等的独立的区域(Region)，每个Region都可以根据需要来扮演Eden区，Survivor区，Old区；在每个Region中维护了自己的记忆集，用来记录各个Region的引用关系；并且在每个Region中设计了两个名为TAMS的指针，把Region的一部分空间划分出来用于并回收时的新对象分配，新对象的分配地址都必须在这两个指针位置以上。支持配置停顿时间，同时收集垃圾的逻辑变成了哪块内存垃圾最多，回收的收益最大就进行收集。

收集过程：

1.初始标记(STW)：标记一下GC Roots 能直接关联到的对象，速度很快

2.并发标记：从GC Roots的直接关联对象开始遍历整个对象图的过程。

3.最终标记(STW)：修正并发时期，用户线程继续运作而导致标记产生变动的那一部分对象的标记记录

4.筛选回收(STW)：将Region中存活的对象进行复制，再回收掉整个Region

优点：

1. 可以指定最大暂停时间
2. 不会产生空间碎片
3. 速度快，设计理念先进

缺点：

1. 占用的额外内存较高
2. 消耗更多的运行资源